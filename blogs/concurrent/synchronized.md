# 1. synchronized 底层实现
> synchronized 代码块是由一对 `monitorenter`/`monitorexit` 指令实现的, `Monitor` 对象是同步的基本实现单元

在 Java 6之前, Monitor 的实现完全依赖与系统内部的互斥锁, 因为需要进行用户态到内核态的切换, 所以同步操作是一个无差别的重量及操作;

在后续的 JDK 版本中, JVM 进行了大量的优化, 提供了三种不同的 Monitor 实现, 也就是常说的
- 偏向锁
- 轻量级锁
- 重量级锁

# 2. 锁的升级和降级
> 是 JVM 优化 synchronized 运行的机制, 当 JVM 检查到不同的竞争状况时, 会自动切换到合适的锁实现, 这种切换就是锁的升级, 降级

- 当没有竞争出现时, 默认使用偏向锁, JVM 会利用 CAS 操作, 在对象头部的 `Mark Word` 部分设置线程 id, 以表示这个对象偏向于当前线程, 所以并不真的涉及互斥, 这样的假设是基于大部分对象生命周期中只会被一个线程锁定, 使用偏向锁可以降低竞争开销.
- 如果有另外的线程试图锁定某个已经被偏向过的对象, JVM 就需要撤销偏向锁吗并切换到轻量级锁实现. 轻量级锁依赖 CAS 操作 `Mark Word` 来试图获取锁, 如果重试成功, 就是用普通的轻量级锁; 否则进一步升级为重量级锁;
- 自旋锁: 竞争锁失败的线程, 并不会真实的在操作系统层面挂起等待, 而是 JVM 会让线程做几个空循环(基于预测不久的将来就能获取到), 在经过果然次循环之后, 如果可以获得锁吗那么进入临界区, 如果还不能获得锁, 才会真正在操作系统层面进行挂起