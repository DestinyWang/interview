# 1. 概述
![](http://oetw0yrii.bkt.clouddn.com/18-9-15/58286916.jpg)

`TIMEWAIT` 状态本身和应用层的客户端或者服务器是没有关系的, 仅仅是主动关闭的一方在使用 `FIN -> ACK -> FIN -> ACK` 四分组正常关闭TCP连接的时候会出现这个 `TIMEWAIT`. 

服务器在处理客户端请求的时候, 如果你的程序设计为服务器主动关闭, 那么你才有可能需要关注这个 `TIMEWAIT` 状态过多的问题.

# 2. `TIMEWAIT` 的作用
TCP 要保证在所有可能的情况下使得所有的数据都能够被正确送达. 当你关闭一个 `socket` 时, 主动关闭一端的 socket 将进入 `TIME_WAIT` 状态, 而被动关闭一方则转入 `CLOSED` 状态, 这的确能够保证所有的数据都被传输. 当一个 socket 关闭的时候, 是通过两端四次挥手完成的, 当一端调用 `close()` 时, 就说明本端没有数据要发送了, 这好似看来在握手完成以后, socket 就都可以处于初始的 `CLOSED` 状态了.

其实不然, 原因是这样安排状态有两个问题, 首先, 我们没有任何机制保证最后的一个ACK能够正常传输; 第二, 网络上仍然有可能有 `残余的数据包(wandering duplicates)`, 我们也必须能够正常处理.

`TIMEWAIT` 就是为了解决这两个问题而生的:
1. 假设最后一个 `ACK` 丢失了, 被动关闭一方会重发它的 `FIN`, 主动关闭一方必须维持一个有效状态信息(`TIMEWAIT`状态下维持), 以便能够重发 `ACK`. 如果主动关闭的 socket 不维持这种状态而进入 `CLOSED` 状态, 那么主动关闭的 socket 在处于 `CLOSED` 状态时, 接收到 `FIN` 后将会响应一个 `RST`, 被动关闭一方接收到 `RST` 后会认为出错了. 如果 TCP 协议想要正常完成必要的操作而终止双方的数据流传输, 就必须完全正确的传输四次握手的四个节, 不能有任何的丢失. 这就是为什么 socket 在关闭后, 仍然处于 `TIME_WAIT` 状态的第一个原因, 因为他要等待以便重发 `ACK`;
2. 假设目前连接的通信双方都已经调用了 `close()`, 双方同时进入 `CLOSED` 的终结状态, 而没有走 `TIME_WAIT` 状态. 会出现如下问题, 现在有一个新的连接被建立起来, 使用的 IP 地址与端口与先前的完全相同, 后建立的连接是原先连接的一个完全复用, 还假定原先的连接中有数据报残存于网络之中, 这样新的连接收到的数据报中有可能是先前连接的数据报, 为了防止这一点, `TCP` 不允许新连接复用 `TIME_WAIT` 状态下的 socket, 处于 `TIME_WAIT` 状态的 socket 在等待两倍的 `MSL` 时间以后(之所以是两倍的 `MSL`, 是由于 `MSL` 是一个数据报在网络中单向发出到认定丢失的时间, 一个数据报有可能在发送途中或是其响应过程中成为残余数据报, 确认一个数据报及其响应的丢弃的需要两倍的MSL), 将会转变为 `CLOSED` 状态. 这就意味着, 一个成功建立的连接，必然使得先前网络中残余的数据报都丢失了.
