> 2000年7月，加州大学伯克利分校的 Eric Brewer 教授在 ACM PODC 会议上提出CAP猜想。2年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP。之后，CAP 理论正式成为分布式计算领域的公认定理。
# 1. CAP 简介

    CPA 理论简单解释为:
    在一个分布式系统中, 当涉及读写操作时, 只能保证一致性, 可用性, 分区容错性三者中的两个, 另外一个必须被牺牲.
    

1. 一致性: 对某个指定版本的客户端来说, 读操作保证能够返回最新的写操作结果;
2. 可用性: 非故障的节点必须在合理的时间内返回合理的响应;
3. 分区容忍性: 当出现网络分区的时候, 系统能够继续履行职责.

# 2. CAP 应用
虽然 CAP 理论是三个要素中只能取得两个, 但放到分布式的环境下时, 由于网络永远是不可靠的, 所以分区是一个必然的现象, 即必须选择 P 要素.

如果我们选择了 CA 而放弃了 P, 那么当发生网络分区时, 为了保证 C, 系统需要禁止写入, 当有写入请求的时候, 系统返回 ERROR, 这又和 A 冲突了;因为 A 要求返回 `no error` 和 `no timeout`. 因此, 分布式系统理论上不可能选择 CA 架构, 只能选择 CP 或者 AP 架构.

## 2.1 CP
为了保证一致性, 当发生网络分区的时候, `node1` 节点上的数据已经更新到 x', 但由于 `node1` 和 `node2` 之间的复制通道中断, 数据 x' 无法同步到 `node2`, 而 `node2` 上的节点上的数据还是 x. 这时, 客户端 `Client` 访问 `node2` 的时候, `node2` 需要返回 ERROR, 提示客户端 "系统现在发生了错误", 这种处理方式违背了可用性的要求, 因此 CAP 三者只能实现 CP.

![](http://oetw0yrii.bkt.clouddn.com/18-7-9/28178406.jpg)

## 2.2 AP
为了保证可用性, 当发生分区现象的时候, `node1` 节点上的数据已经更新到了 x', 但由于 `node1` 和  `node2` 之间的复制通道中断, 数据 x' 无法同步给 `node2`, `node2` 节点上的数据还是 x, 这时客户端 `Client` 访问 `node2` 的时候, `node2` 已经将自己拥有的数据 x 返回给 `Client`, 而实际上集群最新的数据已经是 x', 这就不满足一致性的要求, 因此 CAP 三者只能满足 AP.

![](http://oetw0yrii.bkt.clouddn.com/18-7-9/12016276.jpg)

# 3. CAP 细节
CAP 细节的关键节点:
1. CAP 关注的粒度是数据, 而不是整个系统;  
> C 与 A 之间的取舍可以在同一系统内以非常细小的粒度反复发生, 而每一次决策可能是因为具体的操作, 乃至因为涉及到特定的数据或用户而有所不同.  
CAP 理论的定义和解释中, 往往都是使用 `node`, `system` 这类系统级概念, 但这实际是种误导, 每个系统不可能只处理一种数据, 而是包含多种类型的数据, 有的数据必须选择 `CP`, 有的数据必须选择 `AP`, 如果设计时从系统角度去整体选择其中一种, 必然会顾此失彼;  
在 CAP 理论实践的时候, 需要将系统内的数据按照不同的应用场景和要求进行分类, 每类数据选择不同的策略, 而不是为整个系统选择一种策略;
2. CAP 是忽略网络延迟的  
CAP 的假设中, 没有将延迟考虑进去, 也就是说, 当事务提交的时候, 能够瞬间复制到所有节点. 从本质上讲, CAP 理论中的 C 是不可能完美实现的, 在数据复制的过程中, 节点 A 和 B 的数据并不一致. 在某些严苛的业务场景, 理论上要求选择 CP 而实际上 CP 都做不到, 只能选择 CA(单点写入, 其他节点做备份);
3. 正常情况下, 不存在 CP 和 AP 的选择, 可以同时满足 CA  
CAP 理论告诉我们, 分布式系统只能选择 `CP` 或者 `AP`, 但其实这里的前提是系统发生了 `网络分区` 现象. 如果系统没有发生分区现象, 没有必要放弃 C 或者 A, 应该一起保证, 一次你需要考虑发生分区时选择 `CP` 或者 `AP`, 也要考虑分区没有发生时如何保证 `CA`;
4. 放弃并不等于什么都不做, 需要为分区恢复后做准备  
CAP 理论的牺牲只是说在分区过程中无法保证 C 或者 A, 但并不意味着什么都不做, 因为在系统整个运行周期中, 大部分时间都是正常的, 可以在分区期间做一些操作, 从而让分区故障解决后, 系统能够重新达到 CA 的状态, 比如记录日志等;

# 4. BASE

	BASE 理论本质上是对 CAP 的延伸和补充, 更进一步说, 是对 AP 方案的一个补充.

- 基本可用
- 软状态
- 最终一致

1. 基本可用: 分布式系统在出现故障时, 允许损失部分可用性, 即保证核心可用. 具体选择哪些作为可以损失的业务, 哪些是必须保障的业务, 是一项有挑战性的工作;
2. 软状态: 允许系统存在中间状态, 而该中间状态不会影响系统整体可用性, 即 `CAP` 中的数据不一致;
3. 最终一致性: 系统中所有数据副本经过一定时间后, 最终能够达到一致的状态.  
`一定时间` 和数据特性是强关联的, 不同数据能容忍的不一致时间是不同的.  
`最终` 的含义是不管多长时间, 最终还是要回到一致性的状态.

# 5. Paxos

在paxos算法中，分为4种角色：
- Proposer ：提议者
- Acceptor：决策者
- Client：产生议题者
- Learner：最终决策学习者

上面4种角色中, 提议者和决策者是很重要的, 其他的2个角色在整个算法中应该算做打酱油的, Proposer 就像 Client 的使者，由 Proposer 使者拿着 Client 的议题去向 Acceptor 提议，让 Acceptor 来决策。这里上面出现了个新名词：最终决策。现在来系统的介绍一下paxos算法中所有的行为：
1. Proposer提出议题
2. Acceptor初步接受 或者 Acceptor初步不接受
3. 如果上一步Acceptor初步接受则Proposer再次向Acceptor确认是否最终接受
4. Acceptor 最终接受 或者Acceptor 最终不接受

![](https://images0.cnblogs.com/blog/38637/201312/18123808-b860c61793e247919ee3787ead3430ef.png)

为什么需要3个 Acceptor？因为Acceptor必须是最少大于等于3个，并且必须是奇数个，因为要形成多数派嘛，如果是偶数个，比如4个，2个接受2个不接受，各执己见，没法搞下去了。

为什么是 3 个 `Proposer`? 其实无所谓是多少个了，1~n 都可以的; 如果是 1 个 proposer, 毫无竞争压力, 很顺利的完成2阶段提交, Acceptor们最终批准了事. 如果是多个proposer就比较复杂了.

上面的图中是画了很多节点的, 每个节点需要一台机器么? 答案是不需要的, 上面的图是逻辑图, 物理中, 可以将 Acceptor 和 Proposer 以及 Client 放到一台机器上, 只是使用了不同的端口号罢了, Acceptor 们启动不同端口的 TCP 监听, Proposer 来主动连接即可; 完全可以将 Client, Proposer, Acceptor, Learner 合并到一个程序里面; 这里举一个例子: 比如开发一个JOB程序, JOB程序部署在多台服务器上(数量为奇数), 这些JOB有可能同时处理一项任务, 现在使用 paxos 算法让这些JOB自己来商量由谁(哪台机器)来处理这项任务，这样JOB程序里就需要包含 Client, Proposer, Acceptor, Learner 这 4 大功能，并且需要配置其他 JOB 服务器的 IP 地址.

再举一个例子, zookeeper 常常用来做分布式事务锁. Zookeeper 所使用的 zab 协议也是类似 paxos 协议的. 所有分布式自协商一致性算法都是 paxos 算法的简化或者变种. Client 是使用 zookeeper 服务的机器, Zookeeper 自身包含了 Acceptor, Proposer, Learner. Zookeeper 领导选举就是 paxos 过程, 还有 Client 对 Zookeeper 写 Znode 时，也是要进行 Paxos 过程的，因为不同 Client 可能连接不同的 Zookeeper 服务器来写 Znode, 到底哪个 Client 才能写成功？需要依靠 Zookeeper 的 paxos 保证一致性，写成功 Znode 的 Client 自然就是被最终接受了, Znode 包含了写入 Client 的 IP 与端口, 其他的 Client 也可以读取到这个 Znode 来进行 Learner. 也就是说在 Zookeeper 自身包含了 Learner(因为Zookeeper为了保证自身的一致性而会进行领导选举，所以需要有Learner的内部机制，多个Zookeeper服务器之间需要知道现在谁是领导了), Client端也可以Learner，Learner是广义的.

现在通过一则故事来学习paxos的算法的流程(2阶段提交)，有2个` Client`(老板，老板之间是竞争关系)和 3 个 `Acceptor` (政府官员)：

1. 现在需要对一项议题来进行 paxos 过程，议题是 `A项目我要中标!`，这里的 `我` 指每个带着他的秘书 Proposer 的 Client 老板。
2. Proposer 当然听老板的话了，赶紧带着议题和现金去找 Acceptor 政府官员。
3. 作为政府官员，当然想谁给的钱多就把项目给谁。
4. `roposer-1` 小姐带着现金同时找到了 `Acceptor-1~Acceptor-3` 官员，1 与 2 号官员分别收取了 10 比特币，找到第 3 号官员时，没想到遭到了 3 号官员的鄙视, 3 号官员告诉她, `Proposer-2`给了 11 比特币. 不过没关系, `Proposer-1` 已经得到了 1,2 两个官员的认可，形成了多数派(如果没有形成多数派， `Proposer-1` 会去银行提款在来找官员们给每人 20 比特币，这个过程一直重复每次 +10 比特币，直到多数派的形成)，满意的找老板复命去了，但是此时 `Proposer-2` 保镖找到了 1,2 号官员，分别给了他们 11 比特币, 1,2 号官员的态度立刻转变，都说 `Proposer-2` 的老板懂事，这下子 `Proposer-2` 放心了，搞定了3个官员，找老板复命去了，当然这个过程是第一阶段提交，只是官员们初步接受贿赂而已。故事中的比特币是编号，议题是value。  
这个过程保证了在某一时刻，某一个 proposer 的议题会形成一个多数派进行初步支持；
5. 现在进入第二阶段提交，现在 `proposer-1` 小姐使用分身术(多线程并发)分了 3 个自己分别去找 3 位官员，最先找到了 1 号官员签合同，遭到了 1 号官员的鄙视, 1 号官员告诉他 `proposer-2` 先生给了他11比特币, 因为上一条规则的性质 `proposer-1` 小姐知道 `proposer-2` 第一阶段在她之后又形成了多数派(至少有 2 位官员的赃款被更新了); 此时她赶紧去提款准备重新贿赂这 3 个官员(重新进入第一阶段)，每人 20 比特币。刚给 1 号官员 20 比特币,  1 号官员很高兴初步接受了议题, 还没来得及见到 2,3 号官员的时候, 这时 `proposer-2` 先生也使用分身术分别找 3 位官员(注意这里是 `proposer-2` 的第二阶段)，被第1号官员拒绝了告诉他收到了 20 比特币, 第 2,3 号官员顺利签了合同，这时 2, 3 号官员记录 `client-2` 老板用了11比特币中标, 因为形成了多数派, 所以最终接受了 `Client2` 老板中标这个议题, 对于 `proposer-2` 先生已经出色的完成了工作;
6. 这时 `proposer-1` 小姐找到了 2 号官员, 官员告诉她合同已经签了, 将合同给她看, `proposer-1` 小姐是一个没有什么职业操守的聪明人, 觉得跟 `Client1` 老板混没什么前途，所以将自己的议题修改为 `Client2老板中标`, 并且给了2号官员20比特币, 这样形成了一个多数派. 顺利的再次进入第二阶段. 由于此时没有人竞争了, 顺利的找 3 位官员签合同, 3位官员看到议题与上次一次的合同是一致的, 所以最终接受了, 形成了多数派, `proposer-1` 小姐跳槽到 `Client2` 老板的公司去了.

Paxos过程结束了, 这样, 一致性得到了保证, 算法运行到最后所有的 `proposer` 都投 `client2中标` 所有的 `acceptor` 都接受这个议题, 也就是说在最初的第二阶段, 议题是先入为主的, 谁先占了先机, 后面的 `proposer` 在第一阶段就会学习到这个议题而修改自己本身的议题, 因为这样没职业操守, 才能让一致性得到保证, 这就是paxos算法的一个过程. 原来paxos算法里的角色都是这样的不靠谱, 不过没关系, 结果靠谱就可以了. 该算法就是为了追求结果的一致性.

# 6. 按照 CAP 设计电商系统高可用

	一个电商网站核心模块有会员，订单，商品，支付，促销管理等。
	对于会员模块，包括登录，个人设置，个人订单，购物车，收藏夹等，这些模块保证AP，数据短时间不一致不影响使用。
	订单模块的下单付款扣减库存操作是整个系统的核心，我觉得CA都需要保证，在极端情况下牺牲P是可以的。
	商品模块的商品上下架和库存管理保证CP,搜索功能因为本身就不是实时性非常高的模块，所以保证AP就可以了。
	促销是短时间的数据不一致，结果就是优惠信息看不到，但是已有的优惠要保证可用，而且优惠可以提前预计算，所以可以保证AP
	现在大部分的电商网站对于支付这一块是独立的系统，或者使用第三方的支付宝，微信。其实CAP是由第三方来保证的，支付系统是一个对CAP要求极高的系统，C是必须要保证的，AP中A相对更重要，不能因为分区，导致所有人都不能支付