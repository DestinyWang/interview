# 1. 概念
![](http://oetw0yrii.bkt.clouddn.com/18-7-8/60653153.jpg)
- Serial GC: 最古老的垃圾收集器, 收集工作是单线程的, 并且在进行垃圾收集的过程中, 会进入 `stop-thr-world` 状态, 当然, 单线程也意味着精简的 GC 实现, 无需维护复杂的数据结构, 初始化也很简单, 所以一直是 Client 模式下的 JVM 的默认选项.  
通常将其老年代实现单独称作 `Serial Old`, 它采用 `标记-整理(mark-compact)` 算法, 区别于新生代的复制算法.
- ParNew GC: 本质上是 `Serial GC` 的多线程版本, 最常见的应用场景是配合老年代的 `CMS GC` 工作
- CMS (Concurrent Mark Sweep) GC: 基于 `标记-清除`, 设计目标是尽量减少停顿时间, 这点对于 web 应用非常重要, 但是 CMS 采用 `标记-清除` 算法, 存在内存碎片化问题, 难以避免在长时间运行等情况下发生 Full GC, 导致恶劣的停顿, 此外, CMS 由于强调并发, 会占用更多的 CPU 资源;
- Parallel GC: 早期的 JDK 8 版本中是 server 模式默认的 GC 选择, 也被称作是吞吐量优先的 GC, 它的算法和 `Serial GC` 比较相似, 但更加复杂, 其特点是新生代和老年代都是并行进行的
- G1 GC: 这是一种兼顾吞吐量和停顿时间的 GC 实现, 是 JDK 9 以后的默认 GC 选项. G1 仍然存在年代的划分, 但是其内存结构并不是简单的条带式划分, 而是类似棋盘的一个个 Region. Region 之间是复制算法, 但整体上实际可看作是 `标记-整理` 算法, 可以有效地避免内存碎片, 与此同时 CMS 在 JDK 9 中已经被标记为废弃.

GC 类型:
1. MinorGC：新生代GC，触发条件一般是Eden不足以进行下一次分配
2. MajorGC：与Full GC等价，触发条件是在进行 MinorGC 前，如果 MinorGC 的平均晋升大小比目前老年代的剩余空间大，则会转而触发 MajorGC，当然这里牵扯到不用收集器的区别，除了 CMS 以外，其他收集器都会收集整个 GC 堆
3. stop-the-world：严格来说并不是一个GC种类，只是GC的一种实现，GC期间将整个用户线程停顿，目前SerialGC，ParNew，Parallel Scanvange, ParallelOld, Serial Old全程都会Stop the world。CMS会在几个局部阶段采用stop-the-world

# 2. 垃圾收集原理和基础概念
## 2.1 哪些内存可以被释放
1. 引用计数法:  
为对象添加一个引用计数, 用于记录对象被引用的情况, 如果计数为 0, 即表示对象可以被回收. 但难以处理循环引用的问题
2. 可达性分析:  
将对象及其引用关系看做一个图, 选定活动的对象作为 `GC Roots`, 然后跟踪引用链条, 如果一个对象和 `GC Roots` 之间不可达, 那么即可认为是不可达对象, JVM 会把 `虚拟机栈`, `本地方法栈` 中正在引用的对象, 静态属性引用的对象和常量, 作为 `GC Roots`

方法区无用元数据的回收比较复杂, 初始化类加载器加载的类型是不会进行类卸载的; 而普通类型的卸载, 往往是要求相应的自定义类加载器本身被回收, 所以大量使用动态类型的场合, 需要方式元数据区不会 OOM.

## 2.2 常见垃圾收集算法
1. 复制(Copying)算法: 新生代 GC 基本都是基于复制算法, 过程就是将活着的对象复制到 to 区域, 拷贝过程中将对象顺序放置, 就可以避免内存碎片化.  
而代价就是需要一定程度上的空间浪费; 对于 G1 这种分拆成大量 Region 的 GC 算法, 复制而不是移动意味着 GC 需要维护 Region 之间对象的引用关系.
2. 标记 - 清除(Mark-Sweep)算法: 首先进行标记工作, 标记出所有要回收的对象, 然后进行清除, 这么做除了标记, 清除过程效率有限, 另外不可避免的就是内存碎片化的问题, 容易出现 Full GC;
3. 标记 - 整理(Mark-Compact): 类似于标记 - 清除, 但为避免内存碎片化, 它会在清理过程中将对象移动, 以确保移动后的对象占用连续的内存空间.

# 3. 垃圾收集过程的理解
1. Java 应用不断创建新的对象, 通常都是分配在 Eden 区域, 当其空间占用达到一定阈值的时候, 触发 `Minor GC`, 仍然被引用的对象存活下来, 被复制到 JVM 选择的 `Survivor` 区域; 而没有被引用的对象则被回收;
2. 经过一次 `Minor GC`, Eden 区域就会空闲下来, 直到再次达到 `Minor GC` 触发条件, 这时候, 另外一个 Survivor 区域则会成为 to 区域, Eden 区域存活的对象和 From 区域对象, 都会被复制到 to 区域, 并且存活的年龄计数会被加 1;
3. 类似第二步的过程会发生很多次, 知道有对象年龄计数达到阈值, 就会晋升到老年代.

老年代 GC 取决于选择的 GC 算法, 对于 `标记 - 整理` 算法来说, 老年代中无用的对象被清理后, GC 会将对象进行整理, 以防止内存碎片化.

通常我们把老年代的 GC 叫做 `Major GC`, 将对整个堆进行的清理叫做 Full GC, 但是这个也没有这么绝对, 因为不同的老年代 GC 算法差异很大.

# 4. GC 日志
## 4.1 输出日志参数

    -XX:+PrintGC 输出GC日志
    -XX:+PrintGCDetails 输出GC的详细日志
    -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
    -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2018-07-08T21:53:59.234+0800）
    -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
    -Xloggc:../logs/gc.log 日志文件的输出路径

在使用 `-XX:+PrintGCDetails` 后, 可以在控制台看到如下日志:

    [GC (System.gc()) [PSYoungGen: 3686K->664K(38400K)] 3686K->672K(125952K), 0.0016607 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
    [Full GC (System.gc()) [PSYoungGen: 664K->0K(38400K)] [ParOldGen: 8K->537K(87552K)] 672K->537K(125952K), [Metaspace: 2754K->2754K(1056768K)], 0.0059024 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
    Heap
     PSYoungGen      total 38400K, used 333K [0x00000000d5c00000, 0x00000000d8680000, 0x0000000100000000)
      eden space 33280K, 1% used [0x00000000d5c00000,0x00000000d5c534a8,0x00000000d7c80000)
      from space 5120K, 0% used [0x00000000d7c80000,0x00000000d7c80000,0x00000000d8180000)
      to   space 5120K, 0% used [0x00000000d8180000,0x00000000d8180000,0x00000000d8680000)
     ParOldGen       total 87552K, used 537K [0x0000000081400000, 0x0000000086980000, 0x00000000d5c00000)
      object space 87552K, 0% used [0x0000000081400000,0x00000000814864a0,0x0000000086980000)
     Metaspace       used 2761K, capacity 4486K, committed 4864K, reserved 1056768K
      class space    used 299K, capacity 386K, committed 512K, reserved 1048576K

1. GC日志开头的 `[GC` 和 `[Full GC` 说明了这次垃圾收集的停顿类型，如果有 `Full`，说明这次 GC 发生了 `Stop-The-World`。因为是调用了 `System.gc()` 方法触发的收集，所以会显示 `[Full GC (System.gc())`，不然是没有后面的 `(System.gc())` 的。
2. `[PSYoungGen` 和 `[ParOldGen` 是指 GC 发生的区域，分别代表使用 `Parallel Scavenge` 垃圾收集器的新生代和使用 `Parallel old` 垃圾收集器的老生代。
为什么是这两个垃圾收集器组合呢？因为我的 jvm 开启的模式是 Server，而 Server 模式的默认垃圾收集器组合便是这个，在命令行输入 `java -version` 就可以看到自己的 jvm 默认开启模式。
还有一种是 client 模式，默认组合是 `Serial GC`和 `Serial Old GC`组合。
3. 在方括号中 `PSYoungGen:` 后面的 `3686K->664K(38400K)` 代表的是 GC前该内存区域已使用的容量->GC后该内存区域已使用的容量(该内存区域总容量)
4. 在方括号之外的 `3686K->672K(125952K)` 代表的是 GC前Java堆已使用容量->GC后Java堆已使用容量(Java堆总容量)”
5. 再往后的 `0.0016607 sec` 代表该内存区域GC所占用的时间，单位是秒。
6. 再后面的 `[Times: user=0.00 sys=0.00, real=0.00 secs]`，`user` 代表进程在用户态消耗的 CPU 时间，`sys` 代表代表进程在内核态消耗的 CPU 时间、`real` 代表程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。
7. 至于后面的 `eden` 代表的是 Eden 空间，还有 `from` 和 `to` 代表的是 Survivor 空间。

# 5. GC 的发展趋势
GC 仍然处于飞速发展之中, 目前默认选项 G1 GC 在不断进行改进, 很多我们原来认为的缺点, 如串行的 `Full GC` 等, 都以大幅改进, 如 JDK 10 后, Full GC 已经是并行运行;

即使是 Serial GC, 虽然比较古老, 但由于其简单的设计和较小的开销, 随着云计算的兴起, 在 Serverless 等新的场景下, Serial GC 都有适用场景.

而 CMS 就没有这么幸运, 因为其算法的理论缺陷等原因, 虽然现在还有庞大的用户群体, 但是已经被标记为废弃, 如果没有组织原因主动承担 CMS 的维护工作, 很有可能在将来的版本中彻底移除.

在未来的 JDK 11 中, 新增了两种全新的 GC 方式:
1. Epsilon GC: 简单来说, 就是个不做垃圾收集的 GC, 有的情况下, 可能需要明确判断 GC 本身产生了多大的开销, 这就是其典型的应用场景.
2. ZGC: Oracle 开源的一个超级 GC 实现, 具备令人惊讶的扩展能力, 比如支持 TB 级别的堆大小, 并且保证绝大部分情况下, 延迟都不会超过 10 ms. 目前还处于试验阶段, 仅支持 Linux 64 位平台