# 1. 简介
从内存区域来说, G1 同样存在着年龄的概念, 其内部是类似棋盘状态的一个个 Region 组成.

![](http://oetw0yrii.bkt.clouddn.com/18-7-10/58471083.jpg)

G1 跟踪各个 Region 中的垃圾堆积的价值大小, 在后台维护一个列表, 每次根据允许的收集时间, 优先回收价值最大的 Region

Region 大小是一致的, 数值是在 1M 到 32M 之间的一个 2 的幂指数, JVM 会尽量划分 2048 个左右, 同等大小的 Region, 这个数字可以手动调整, G1 也会根据堆大小自动进行调整.

G1 的实现中, 年代是一个逻辑概念, 具体体现在, 一部分 Region 是作为 Eden, 一部分作为 Survivor, 除了意料之中的 Old Region, G1 会将超过 Region 50% 大小的对象归类为 Humongous 对象, 并放置在相应的 Region 中, 逻辑上 Humongous Region 算是老年代的一部分, 因为复制这样的大对象是很昂贵的操作, 并不适合新生代 GC 的复制算法.

> Region 设计的副作用: Region 大小和大对象很难保证一致, 这会导致空间的浪费, 特别大的对象可能占用超过一个 Region, 并且 Region 太小也不合适, 会令分配大对象的时候更难找到连续空间. 解决办法就是 Region 的大小尽量设置大一些

## 2. GC 算法

    G1 选择的是复合算法
    新生代, G1 采用并行的复制算法, 所以同样会发生 stop-the-world 暂停;
    老年代, 大部分情况下都是并发标记, 而整理则是和新生代 GC 时捎带进行的, 而且不是整体性的整理, 而是增量进行的.
    
习惯上, 新生代 GC 叫做 Minor GC, 老年代 GC 叫做 Major GC, 区别于整体性的 Full GC, 但是在 G1 中, 这种概念已经不再准确:
- Minor GC 仍然存在, 虽然具体过程会有区别
- 老年代回收, 依靠 Mixed GC. 并发标记结束后, JVM 就有足够的信息进行垃圾收集, Mixed GC 不仅会同时清理 Eden, Survivor, 而且还会清理部分 Old 区域

![](http://oetw0yrii.bkt.clouddn.com/18-7-10/95403317.jpg)

G1 相关的概念非常多, 有一个重点就是 Remembered Set, 用于记录和维护 Region 之间对象的引用关系. 新生代 GC 是复制算法, 在从 from 区移动到 to 区的时候, 本质上是生成一个新的对象, 在这个过程中, 必须要保证老年代到新生代的跨区引用仍然有效.

![](http://oetw0yrii.bkt.clouddn.com/18-7-10/85403963.jpg)

- Humongous 对象的分配和回收, 这是很多内存问题的来源, Humongous Region 作为老年代的一部分, 通常认为他会在并发标记结束后才进行回收, 但是在新版 G1 中, Humongous 对象回收采取了更加激进的策略, G1 记录了老年代 Region 间对象的引用, Humongous 对象数量有限, 所以能够快速的知道是否有老年代对象引用它, 如果没有, 能够阻止它被回收的唯一可能就是新生代是否有对象引用了它, 但这个信息可以在 Young GC 时知道, 所以完全可以在 Young GC 中就进行 Humongous 对象的回收, 不像其他老年代对象一样, 等待并发标记的结束.
- 在垃圾回收过程中, G1 会把新创建的字符串对象放入队列中, 然后在 Young GC 后, 并发地将一致的字符串进行排重, 也就是将其引用同一个数组
- G1 在并发标记结束后, JVM 即进行类型卸载
- 老年代对象回收, 基本要等到并发标记结束, 这就意味着如果并发标记不及时, 导致堆已满, 但老年代空间还未完成回收, 就会触发 Full GC, 所以触发并发标记的时机很重要, JDK 9 之后的 G1, JVM 会在运行时进行采样以及自适应动态调整并发标记启动时机


# 3. 概念
## 3.1 G1 Young GC
Young GC主要是对Eden区进行GC，它在Eden空间耗尽时会被触发。在这种情况下，Eden空间的数据移动到Survivor空间中，如果Survivor空间不够，Eden空间的部分数据会直接晋升到年老代空间。Survivor区的数据移动到新的Survivor区中，也有部分数据晋升到老年代空间中。最终Eden空间的数据为空，GC停止工作，应用线程继续执行。

![image](http://jbcdn2.b0.upaiyun.com/2016/12/50877d4b41c80010b1f131de5759b689.png)

![](http://jbcdn2.b0.upaiyun.com/2016/12/a245f9decda81cbf12f69412d38f3177.png)

这时，我们需要考虑一个问题，如果仅仅 GC  新生代对象，我们如何找到所有的根对象呢？ 老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1 引进了 RSet 的概念。它的全称是 `Remembered Set`，作用是跟踪指向某个 heap 区内的对象引用。

![](http://jbcdn2.b0.upaiyun.com/2016/12/bd7d9f4a8e43312cb189863a568c4630.png)

在 CMS 中，也有 RSet 的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。

但在G1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要GC的分区引用也扫描了。于是G1中使用point-in来解决。point-in的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。

需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（Card Table）。一个Card Table将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间。Card Table通常为字节数组，由Card的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。

Young GC 阶段：

1. 根扫描: 静态和本地对象被扫描
2. 更新RS: 处理dirty card队列更新RS
3. 处理RS: 检测从年轻代指向年老代的对象
4. 对象拷贝: 拷贝存活的对象到survivor/old区域
5. 处理引用队列: 软引用，弱引用，虚引用处理

## 3.2 G1 Mix GC
Mix GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。

它的GC步骤分2步：

- 全局并发标记（global concurrent marking）
- 拷贝存活对象（evacuation）

在进行Mix GC之前，会先进行global concurrent marking（全局并发标记）。 global concurrent marking的执行过程是怎样的呢？

在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为五个步骤：

1. 初始标记（initial mark，STW）
在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。
2. 根区域扫描（root region scan）
G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。
3. 并发标记（Concurrent Marking）
G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断
4. 最终标记（Remark，STW）
该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理。
5. 清除垃圾（Cleanup，STW）
在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。

**三色标记法**

提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。 首先，我们将对象分成三种类型的。

- 黑色:根对象，或者该对象与它的子对象都被扫描;
- 灰色:对象本身被扫描,但还没扫描完该对象中的子对象;
- 白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象

当GC开始扫描对象时，按照如下图步骤进行对象的扫描：

根对象被置为黑色，子对象被置为灰色。

![image](http://jbcdn2.b0.upaiyun.com/2016/12/8efbc44ba3b845e6086a83377e912bb9.png)

继续由灰色遍历,将已扫描了子对象的对象置为黑色。

![](http://jbcdn2.b0.upaiyun.com/2016/12/f56ab01de2138dc3b4a4bb3d50f54594.png)

遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。

![](http://jbcdn2.b0.upaiyun.com/2016/12/c4f581fd4a8877375d54a55e4af27841.png)

这看起来很美好，但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题

我们看下面一种情况，当垃圾收集器扫描到下面情况时：

![](http://jbcdn2.b0.upaiyun.com/2016/12/5dd0686b02e1898ec1a987c2e1571548.png)

这时候应用程序执行了以下操作：

```java
A.c = C
B.c = null
```

这样，对象的状态图变成如下情形：

![](http://jbcdn2.b0.upaiyun.com/2016/12/78ad6fbc199fca514a5336b2167bd8f7.png)

这时候垃圾收集器再标记扫描的时候就会下图成这样：

![](http://jbcdn2.b0.upaiyun.com/2016/12/f4765bacd1941792df63c6296ad12e3a.png)

很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC标记的对象不丢失呢？有如下2中可行的方式：

在插入的时候记录对象
在删除的时候记录对象
刚好这对应CMS和G1的2种不同实现方式：

- 在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。
- 在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有3个步骤：

1. 在开始标记的时候生成一个快照图标记存活对象
2. 在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用所指向的对象都变成非白的）
3. 可能存在游离的垃圾，将在下次被收集

这样，G1到现在可以知道哪些老的分区可回收垃圾最多。 当全局并发标记完成后，在某个时刻，就开始了Mix GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区。混合式垃圾收集如下图：

![](http://jbcdn2.b0.upaiyun.com/2016/12/0860c63775ccbc265095b5a844f0d381.png)

混合式GC也是采用的复制的清理策略，当GC完成后，会重新释放空间。

![](http://jbcdn2.b0.upaiyun.com/2016/12/599b50c478126754a1cc614a85b149bd.png)

