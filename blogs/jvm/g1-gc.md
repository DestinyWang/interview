# 1. 简介
从内存区域来说, G1 同样存在着年龄的概念, 其内部是类似棋盘状态的一个个 Region 组成.

![](http://oetw0yrii.bkt.clouddn.com/18-7-10/58471083.jpg)

G1 跟踪各个 Region 中的垃圾堆积的价值大小, 在后台维护一个列表, 每次根据允许的收集时间, 优先回收价值最大的 Region

Region 大小是一致的, 数值是在 1M 到 32M 之间的一个 2 的幂指数, JVM 会尽量划分 2048 个左右, 同等大小的 Region, 这个数字可以手动调整, G1 也会根据堆大小自动进行调整.

G1 的实现中, 年代是一个逻辑概念, 具体体现在, 一部分 Region 是作为 Eden, 一部分作为 Survivor, 除了意料之中的 Old Region, G1 会将超过 Region 50% 大小的对象归类为 Humongous 对象, 并放置在相应的 Region 中, 逻辑上 Humongous Region 算是老年代的一部分, 因为复制这样的大对象是很昂贵的操作, 并不适合新生代 GC 的复制算法.

> Region 设计的副作用: Region 大小和大对象很难保证一致, 这会导致空间的浪费, 特别大的对象可能占用超过一个 Region, 并且 Region 太小也不合适, 会令分配大对象的时候更难找到连续空间. 解决办法就是 Region 的大小尽量设置大一些

## 2. GC 算法

    G1 选择的是复合算法
    新生代, G1 采用并行的复制算法, 所以同样会发生 stop-the-world 暂停;
    老年代, 大部分情况下都是并发标记, 而整理则是和新生代 GC 时捎带进行的, 而且不是整体性的整理, 而是增量进行的.
    
习惯上, 新生代 GC 叫做 Minor GC, 老年代 GC 叫做 Major GC, 区别于整体性的 Full GC, 但是在 G1 中, 这种概念已经不再准确:
- Minor GC 仍然存在, 虽然具体过程会有区别
- 老年代回收, 依靠 Mixed GC. 并发标记结束后, JVM 就有足够的信息进行垃圾收集, Mixed GC 不仅会同时清理 Eden, Survivor, 而且还会清理部分 Old 区域

![](http://oetw0yrii.bkt.clouddn.com/18-7-10/95403317.jpg)

G1 相关的概念非常多, 有一个重点就是 Remembered Set, 用于记录和维护 Region 之间对象的引用关系. 新生代 GC 是复制算法, 在从 from 区移动到 to 区的时候, 本质上是生成一个新的对象, 在这个过程中, 必须要保证老年代到新生代的跨区引用仍然有效.

![](http://oetw0yrii.bkt.clouddn.com/18-7-10/85403963.jpg)

- Humongous 对象的分配和回收, 这是很多内存问题的来源, Humongous Region 作为老年代的一部分, 通常认为他会在并发标记结束后才进行回收, 但是在新版 G1 中, Humongous 对象回收采取了更加激进的策略, G1 记录了老年代 Region 间对象的引用, Humongous 对象数量有限, 所以能够快速的知道是否有老年代对象引用它, 如果没有, 能够阻止它被回收的唯一可能就是新生代是否有对象引用了它, 但这个信息可以在 Young GC 时知道, 所以完全可以在 Young GC 中就进行 Humongous 对象的回收, 不像其他老年代对象一样, 等待并发标记的结束.
- 在垃圾回收过程中, G1 会把新创建的字符串对象放入队列中, 然后在 Young GC 后, 并发地将一致的字符串进行排重, 也就是将其引用同一个数组
- G1 在并发标记结束后, JVM 即进行类型卸载
- 老年代对象回收, 基本要等到并发标记结束, 这就意味着如果并发标记不及时, 导致堆已满, 但老年代空间还未完成回收, 就会触发 Full GC, 所以触发并发标记的时机很重要, JDK 9 之后的 G1, JVM 会在运行时进行采样以及自适应动态调整并发标记启动时机


# 3. 概念
## 3.1 Minor GC
从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。这一定义既清晰又易于理解。但是，当发生Minor GC事件的时候，有一些有趣的地方需要注意到：
1. 当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。
2. 内存池被填满的时候，其中的内容全部会被复制，指针会从0开始跟踪空闲内存。Eden 和 Survivor 区进行了标记和复制操作，取代了经典的标记、扫描、压缩、清理操作。所以 Eden 和 Survivor 区不存在内存碎片。写指针总是停留在所使用内存池的顶部。
3. 执行 Minor GC 操作时，不会影响到永久代。从永久代到年轻代的引用被当成 GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。
4. 质疑常规的认知，所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）”，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就 是，大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，Minor GC 执行时暂停的时间将会长很多。  

所以 Minor GC 的情况就相当清楚了——每次 Minor GC 会清理年轻代的内存。

## 3.2 Major GC
老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

MajorGC 采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。

当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。

## 3.3 Mixed GC

    收集整个新生代和部分老年代, 目前只有 G1 采用这个模式
    
YoungGC：收集年轻代里的Region  
MixGC：年轻代的所有Region+全局并发标记阶段选出的收益高的Region
无论是YoungGC还是MixGC都只是并发拷贝的阶段。

分代G1模式下选择CSet有两种子模式，分别对应YoungGC和mixedGC：
- YoungGC：CSet就是所有年轻代里面的Region
- MixedGC：CSet是所有年轻代里的Region加上在全局并发标记阶段标记出来的收益高的Region

G1 的运行过程是这样的，会在 Young GC 和 Mix GC 之间不断的切换运行，同时定期的做全局并发标记，在实在赶不上回收速度的情况下使用Full GC(Serial GC)。初始标记是搭在YoungGC上执行的，在进行全局并发标记的时候不会做Mix GC，在做Mix GC的时候也不会启动初始标记阶段。当MixGC赶不上对象产生的速度的时候就退化成Full GC，这一点是需要重点调优的地方。

## 3.3 SATB
SATB的全称是 Snapchat-At-The-Beginning。SATB 是维持并发GC的一种手段。G1并发的基础就是SATB。SATB可以理解成在GC开始之前对堆内存里的对象做一次快照，此时活的对象就认为是活的，从而形成一个对象图。在GC收集的时候，新生代的对象也认为是活的对象，除此之外其他不可达的对象都认为是垃圾对象。

如何找到在GC的过程中分配的对象呢？每个region记录着两个top-at-mark-start（TAMS）指针，分别为prevTAMS和nextTAMS。在TAMS以上的对象就是新分配的，因而被视为隐式marked。通过这种方式我们就找到了在GC过程中新分配的对象，并把这些对象认为是活的对象。

解决了对象在GC过程中分配的问题，那么在GC过程中引用发生变化的问题怎么解决呢， G1给出的解决办法是通过Write Barrier。Write Barrier就是对引用字段进行赋值做了环切。通过Write Barrier就可以了解到哪些引用对象发生了什么样的变化。

## 3.4 全局并发标记阶段
全局并发标记阶段是基于 SATB 的，与 CMS 有些类似，但是也有不同的地方，主要的几个阶段如下：

1. 初始标记: 该阶段会 STW。扫描根集合，将所有通过根集合直达的对象压入扫描栈，等待后续的处理。在 G1 中初始标记阶段是借助 Young GC 的暂停进行的，不需要额外的暂停。虽然加长了 Young GC 的暂停时间，但是从总体上来说还是提高的GC的效率。
2. 并发标记: 该阶段不需要 STW。这个阶段不断的从扫描栈中取出对象进行扫描，将扫描到的对象的字段再压入扫描栈中，依次递归，直到扫描栈为空，也就是说 trace 了所有 GCRoot 直达的对象。同时这个阶段还会扫描 SATB write barrier 所记录下的引用。
3. 最终标记: 也叫 Remark，这个阶段也是 STW 的。这个阶段会处理在并发标记阶段 `write barrier` 记录下的引用，同时进行弱引用的处理。这个阶段与 `CMS` 的最大的区别是 `CMS` 在这个阶段会扫描整个根集合，Eden也会作为根集合的一部分被扫描，因此耗时可能会很长。
4. 清理: 该阶段会STW。清点和重置标记状态。这个阶段有点像 mark-sweep 中的 sweep 阶段，这个阶段并不会实际上去做垃圾的收集，只是去根据停顿模型来预测出 CSet，等待 evacuation 阶段来回收。