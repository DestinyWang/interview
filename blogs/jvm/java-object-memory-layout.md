# 1. 对象的创建过程
当 JVM 执行一条 `new` 指令的时候, 首先将检查这个指令能否在常量池中定位到一个类的引用符号, 并检查这个符号引用代表的类是否已被加载, 解析和初始化过, 如果没有, 首先要执行类加载过程.

如果加载完成, JVM 将为新生对象分配内存空间, 对象所需的空间大小在类加载完成后即可确定, 需要将一块确定大小的空间从堆内存中划分出来:
- 在使用 Serial, ParNew 等带 `Compact(压缩整理)` 过程的 GC 算法时, 会采用指针碰撞: 在堆空间中存在一个指针, 一侧表示使用过的内存, 另一侧表示未使用的内存, 分配的过程其实就是移动指针的过程;
- 在使用 CMS 这种基于 `Mark-Sweep(标记-清除)` 的 GC 算法时, 由于此时堆内存中未使用的空间并不是连续的, 而是和已使用的内存相互交错, JVM 必须维护一个空闲内存列表 `Free List`

此外, 还需要考虑多线程下的分配行为是否安全, 否则可能会出现两个线程同时分配空间, 指针还没来得及修改, 另一个线程又开始分配的情况, 解决方案: 
- 默认采用 CAS 配上失败重试机制的方式保证操作的原子性;
- 本地线程分配缓冲(`Thread Local Allocation Buffer, TLAB`), 即每个线程在 Java 堆中预留一块空间, 分配空间时在先在自身的缓冲区中完成, 只有缓冲区耗尽时才进行同步锁定, 可以通过命令 `-XX:+UseTLAB` 来开启;

接下来, JVM 需要对对象进行一系列的设置, 包括对象是哪个类的实例, 如果查询元数据, HashCode, GC分代年龄等信息, 这些存储在对象的 `对象头(Object Head)` 中. 

一般来说, `new` 指令之后都会进行 `<init>` 方法, 按照程序员的意愿进行初始化.

# 2. 对象的内存布局
在 HotSpot 中, 对象的内存布局一共可分为三个区域:
- 对象头
- 实例数据
- 对齐填充

## 2.1 对象头
主要包括两部分信息:

对象自身的运行时数据(`Mark Word)`, 长度为 32 bit 或 64 bit, 主要包括以下内容: 
  - HashCode
  - GC 分代年龄
  - 锁状态标志
  - 线程持有的锁
  - 偏向锁 ID
  - 偏向时间戳
  
由于 MarkWord 存储的信息是与对象自身定义的数据无关的数据, 因此被设计为一个非固定的数据结构, 以便能够最大化利用空间. 它会根据对象的状态复用存储空间;

对象在不同状态下的 MarkWord 使用情况见下表:

状态 | 标志位 | 存储内容
---|---|---
未锁定 | 01 | HashCode, 分代年龄
可偏向 | 01 | 偏向线程ID, 偏向时间戳, 分代年龄
轻量级锁定 | 00 | 指向锁记录的指针
膨胀(重量级锁) | 10 | 指向重量级锁的指针
GC 标记 | 11 | 空(不需要记录信息)



类型指针: 对象指向它的类元数据的指针, 虚拟机通过这个指针来确定这个对象是哪个类的实例.


偏向锁 / 轻量级锁的状态转换及对象的 Mark Word 的关系
![](http://oetw0yrii.bkt.clouddn.com/18-9-10/94688740.jpg)

## 2.2 实例数据
对象真正存储的有效数据

不论是父类集成而来, 还是自身定义, 都需要进行保存, 这部分的存储顺序会受到 JVM `分配策略参数(FieldsAllocationStyle)` 和字段在 Java 源码中定义的顺序的影响/ HotSpot 默认的分配策略是 longs/doubles, ints, shorts/chars, bytes/booleans, oops(Ordinary Object Pointers), 相同宽度的字段总是被分配到一起, 在满足这个的前提条件下, 父类中定义的变量会出现在子类之前.

## 2.3 对齐填充
仅仅起着占位符的作用, 没有特殊含义, 在示例数据没有对齐时, 会根据实际情况进行填充.