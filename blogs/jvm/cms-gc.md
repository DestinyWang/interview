CMS 收集器有三种基本操作:
1. CMS 收集器会对新生代的对象进行回收(所有的应用线程都会被暂停);
2. CMS 收集器会启动一个并发的线程对老年代空间的垃圾进行回收;
3. 如果有必要, CMS 会发起 Full GC;

CMS 与 Parallel 收集器的新生代垃圾收集非常相似, 对线从 Eden 空间移动到 Survivor 空间

回收过程分为好几个阶段, 虽然主要的并发回收阶段都使用了后台线程进行工作, 有些阶段还是会暂停所有的应用线程, 并因此引入短暂的停顿.

## 1. CMS 的主要过程

### 1.1 初始标记
并发回收由`初始标记`阶段开始, 这个阶段会暂停所有的应用程序线程.

    89.976: [GC [1 CMS-initial-mark: 702254K(1398144k)]
                    772530k(2027264k), 0.0830120 secs]
                    [Times: user=0.08 sys=0.00, real=0.08 secs]
                    
这个阶段的主要任务是找到堆中所有的垃圾回收根节点对象, 从第一次组数据可以看到这个例子中对象占用了老年代空间 1398MB 中的 702MB 空间, 第二组数据显示整个堆的大小为 2027MB, 其中 772MB 被占用, 应用程序线程在这个 CMS 回收周期中被暂停了 0.08 秒.

### 1.2 并发标记
这个阶段中应用线程可以持续运行, 不会被中断.

    90.059: [CMS-concurrent-mark-start]
    90.887: [CMS-concurrent-mark: 0.823/0.828 secs]
                    [Times: user=1.11 sys=0.00 real=0.83 secs]
                    
标记阶段耗时 0.83 秒, 由于这个阶段进行的工作仅仅是标记, 不会对堆的使用情况产生实质性的改变, 所以没有任何相关的数据输出, 如果这个阶段还有数据输出, 很可能由于这 0.83 秒内新生代对象的分配导致了堆的增长, 因为应用程序线程还在持续运行着.

### 1.3 并发预清理

    90.892: [CMS-concurrent-abortable-preclean-start]
    92.392: [GC 92.393: [ParNew: 629120K->69888K(629120K), 0.1289040 secs]
                    1331374K->802967K(2027264K), 0.1290200 sesc]
                    [Times: user=0.44 sys=0.01 real=0.12 secs]

CMS是以获取最短停顿时间为目的的GC, 重标标记需要`STW(Stop The World)`, 因此重标记的工作尽可能多的在并发阶段完成来减少STW的时间。

> 此阶段标记从新生代晋升的对象, 新分配到老年代的对象以及在并发阶段被修改了的对象.

关键问题: 如何确定老年代对象是活着的?

通过 `GC ROOT TRACING` 可到达的对象就是活着的

![image](http://images2015.cnblogs.com/blog/572213/201604/572213-20160411232307395-1644993623.png)

老年代进行GC时如何确保上图中Current Obj标记为活着的？  
答案是必须扫描新生代来确保, 这也是为什么CMS虽然是老年代的gc, 但仍要扫描新生代的原因.

> CMS 使用了一种快速识别新生代和老年代存活对象的机制

#### 新生代
CMS 有两个参数: `CMSScheduleRemarkEdenSizeThreshold`, `CMSScheduleRemarkEdenPenetration`, 默认值分别是`2M`, `50%`. 两个参数组合起来的意思是预清理后, eden空间使用超过`2M`时启动可中断的并发预清理(CMS-concurrent-abortable-preclean), 直到eden空间使用率达到50%时中断, 进入remark阶段. 

如果能在可中断的预清理阶段发生一次`Minor GC`, 即可解决问题.

而如果没有发生 `Minor GC`, top(下一个可以分配的地址空间)以下的所有空间被认为是一个块(这个块包含了新生代大部分内容), 这种块对于remark阶段并不会起到多少作用, 因此并行效率也会降低. 

#### 老年代
老年代的机制与一个叫`CARD TABLE`的东西(这个东西其实就是个数组, 数组中每个位置存的是一个byte)密不可分.

CMS将老年代的空间分成大小为`512bytes`的块, `card table`中的每个元素对应着一个块.

并发标记时, 如果某个对象的引用发生了变化, 就标记该对象所在的块为 `dirty card`, 并发预清理阶段就会重新扫描该块, 将该对象引用的对象标识为可达.

> 并发标记时对象的状态:

![](http://images2015.cnblogs.com/blog/572213/201604/572213-20160412075353457-1519877684.png)

> 随后 current obj 的引用发生了变化:

![](http://images2015.cnblogs.com/blog/572213/201604/572213-20160411232412316-1236604269.png)

current obj所在的块被标记为了dirty card


### 1.4 重新标记
暂停所有用户线程，重新扫描堆中的对象，进行可达性分析,标记活着的对象。  
有了前面的基础，这个阶段的工作量被大大减轻，停顿时间因此也会减少。

### 1.5 并发清理
用户线程被重新激活，同时清理那些无效的对象

### 1.6 并发重置
这是并发运行的最后一个阶段, CMS 垃圾回收的周期至此告终, 老年代空间中没有被引用的对象被回收.

而新生代发生垃圾回收, 同时老年代又没有足够的空间容纳晋升的对象时, CMS 垃圾回收就会退化成 Full GC, 所有的应用线程都会被暂停, 老年代中所有的无效对象都会被回收.


## 2. CMS 的弊端
### 2.1 CMS 对 CPU 资源非常敏感
CMS 默认启动的回收线程数是

```
(CPU核数 + 3) / 4
```
当 CPU 在 4 个以上时, 并发回收时垃圾收集线程不少于 25% 的CPU 资源, 并且随着 CPU 数量的增加而下降.

但当 CPU 数量小于 4 个时, CMS 对用户程序的影响可能就变得很大.

### 2.2 CMS 无法处理浮动垃圾
由于 CMS 并发清理阶段用户线程还在运行, 会不断有垃圾产生, 这部分垃圾出现在标记过程之后, CMS 无法在当次收集中处理掉它们, 只能留待下一次处理

### 2.3 会产生大量碎片
CMS 是基于 `标记-清除` 算法实现的收集器, 可能在收集完成后产生大量碎片, 从而导致提前进行 `Full GC`